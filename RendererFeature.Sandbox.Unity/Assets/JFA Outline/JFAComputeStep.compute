#pragma kernel JumpFlood
#pragma target 4.5
#pragma enable_d3d11_debug_symbols

// xy = seed position (center of the pixel), z = distance squared
// previous step initially cleared to (-1, -1, 1e10, 0)
Texture2D<float4> inputBuffer;
RWTexture2D<float4> outputBuffer;   

int2 bufferResolution;
int jumpDistance; // current jump distance (e.g. 128, 64, 32 ...)

float4 UpdateCurrent(float4 current, int2 currentId, int OffsetX, int OffsetY)
{
    int2 sampleOffset = currentId + int2(OffsetX, OffsetY) * jumpDistance;

    if ( sampleOffset.x < 0
        || sampleOffset.y < 0
        || sampleOffset.x >= bufferResolution.x
        || sampleOffset.y >= bufferResolution.y)
    {
        // sampleOffset is outside of buffer
        return current;
    }

    float4 candidate = inputBuffer.Load(int3(sampleOffset, 0));
    
    if (candidate.x < 0)
    {
        // This candidate is not seeded yet
        return current;
    }

    // we refer to the pixel center hereto calculate distances
    float2 pixelCenter = (float2)currentId + float2(0.5, 0.5);
    float2 deltaPos = candidate.xy - pixelCenter;
    float distSq = dot(deltaPos, deltaPos);

    if (distSq < current.z)
    {
        return float4( candidate.xy, distSq, current.w );
    }

    return current;
}

[numthreads(8, 8, 1)]
void JumpFlood(int3 id : SV_DispatchThreadID)
{
    if (id.x >= bufferResolution.x || id.y >= bufferResolution.y)
    {
        return;
    }

    float4 current = inputBuffer.Load(int3(id.xy, 0));
    
    current = UpdateCurrent(current, id.xy, -1, -1);
    current = UpdateCurrent(current, id.xy, -1, 0);
    current = UpdateCurrent(current, id.xy, -1, 1);
    
    current = UpdateCurrent(current, id.xy, 0, -1);
    current = UpdateCurrent(current, id.xy, 0, 1);

    current = UpdateCurrent(current, id.xy, 1, -1);
    current = UpdateCurrent(current, id.xy, 1, 0);
    current = UpdateCurrent(current, id.xy, 1, 1);

    outputBuffer[id.xy] = current;
}
